{
  "address": "0xA7d635c8de9a58a228AA69353a1699C7Cc240DCF",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IStandaloneReverseRegistrar",
          "name": "_defaultRegistrar",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "dns",
          "type": "bytes"
        }
      ],
      "name": "DNSDecodingFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        }
      ],
      "name": "UnreachableName",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "selector",
          "type": "bytes4"
        }
      ],
      "name": "UnsupportedResolverProfile",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "chainId",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "coinType",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultRegistrar",
      "outputs": [
        {
          "internalType": "contract IStandaloneReverseRegistrar",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "name",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "result",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addrs",
          "type": "address[]"
        },
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "resolveNames",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "names",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe3b955bad34a8f2e8702ae7710f01597b7ee843e29e38c5069a3d1228168766e",
  "receipt": {
    "to": null,
    "from": "0x69420f05A11f617B4B74fFe2E04B2D300dFA556F",
    "contractAddress": "0xA7d635c8de9a58a228AA69353a1699C7Cc240DCF",
    "transactionIndex": 32,
    "gasUsed": "1287182",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x059c0bf7abb4c1f9c436052f5a0e30f1b76aa709b2fcb75232b82130949504a4",
    "transactionHash": "0xe3b955bad34a8f2e8702ae7710f01597b7ee843e29e38c5069a3d1228168766e",
    "logs": [],
    "blockNumber": 22764871,
    "cumulativeGasUsed": "4919844",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x283F227c4Bd38ecE252C4Ae7ECE650B0e913f1f9"
  ],
  "numDeployments": 1,
  "solcInputHash": "66ae8ece08cf62450fe50df51b345695",
  "metadata": "{\"compiler\":{\"version\":\"0.8.26+commit.8a97fa7a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IStandaloneReverseRegistrar\",\"name\":\"_defaultRegistrar\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dns\",\"type\":\"bytes\"}],\"name\":\"DNSDecodingFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"UnreachableName\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"UnsupportedResolverProfile\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRegistrar\",\"outputs\":[{\"internalType\":\"contract IStandaloneReverseRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"resolveNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"DNSDecodingFailed(bytes)\":[{\"details\":\"The DNS-encoded name is malformed.\"}],\"UnreachableName(bytes)\":[{\"details\":\"Error selector: `0x5fe9a5df`\"}],\"UnsupportedResolverProfile(bytes4)\":[{\"details\":\"Error selector: `0x7b1c461b`\"}]},\"kind\":\"dev\",\"methods\":{\"resolve(bytes,bytes)\":{\"details\":\"This function may execute over multiple steps.\",\"params\":{\"data\":\"The resolution data, as specified in ENSIP-10.\",\"name\":\"The reverse name to resolve, in normalised and DNS-encoded form.\"},\"returns\":{\"result\":\"The encoded response for the requested profile.\"}},\"resolveNames(address[],uint8)\":{\"details\":\"This function may execute over multiple steps.\",\"params\":{\"addrs\":\"The addresses to resolve.\",\"perPage\":\"The maximum number of addresses to resolve per call.                Ignored if this function does not revert `OffchainLookup`.\"},\"returns\":{\"names\":\"The resolved names.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"title\":\"Default Reverse Resolver\",\"version\":1},\"userdoc\":{\"errors\":{\"UnreachableName(bytes)\":[{\"notice\":\"`name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace.\"}],\"UnsupportedResolverProfile(bytes4)\":[{\"notice\":\"`resolve()` was called with a profile other than `name()` or `addr(*)`.\"}]},\"kind\":\"user\",\"methods\":{\"chainId()\":{\"notice\":\"The EVM Chain ID corresponding to the `coinType`.\"},\"coinType()\":{\"notice\":\"The coin type for the resolver.\"},\"defaultRegistrar()\":{\"notice\":\"The reverse registrar contract for \\\"default.reverse\\\".\"},\"resolve(bytes,bytes)\":{\"notice\":\"Resolves the following profiles according to ENSIP-10:         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.         Callers should enable EIP-3668.\"},\"resolveNames(address[],uint8)\":{\"notice\":\"Resolve multiple EVM addresses to names.         Callers should enable EIP-3668.\"}},\"notice\":\"Reverses an EVM address using the `IStandaloneReverseRegistrar` for \\\"default.reverse\\\".\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/reverseResolver/DefaultReverseResolver.sol\":\"DefaultReverseResolver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts-v5/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the legacy (ETH-only) addr function.\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /// Returns the address associated with an ENS node.\\n    /// @param node The ENS node to query.\\n    /// @return The associated address.\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0x91dd0c350698c505d6c7e4c919da9f981d4b8d7ad062e25073fa1f6af7cb79d1\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// Interface for the new (multicoin) addr function.\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x8da5dd0fc1c5ab4f47e03c23126976a86d4b2dbeac161e70e3af9e2a13330cf0\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/IExtendedResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5d81521cfae7d9a4475d27533cd8ed0d3475d369eb0674fd90ffbdbdf292faa3\",\"license\":\"MIT\"},\"contracts/resolvers/profiles/INameResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface INameResolver {\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    /// Returns the name associated with an ENS node, for reverse records.\\n    /// Defined in EIP181.\\n    /// @param node The ENS node to query.\\n    /// @return The associated name.\\n    function name(bytes32 node) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x3ab986332e0baad7aeb4b426aace3aa1c235be5efff8db4b6f1ce501bcdd9e68\",\"license\":\"MIT\"},\"contracts/reverseRegistrar/IStandaloneReverseRegistrar.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Interface for a standalone reverse registrar.\\ninterface IStandaloneReverseRegistrar {\\n    /// @notice Emitted when the name for an address is changed.\\n    ///\\n    /// @param addr The address of the reverse record.\\n    /// @param name The name of the reverse record.\\n    event NameForAddrChanged(address indexed addr, string name);\\n\\n    /// @notice Returns the name for an address.\\n    ///\\n    /// @param addr The address to get the name for.\\n    /// @return The name for the address.\\n    function nameForAddr(address addr) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x693ab3a5dcd95a80a2a4a2418ce48092d20d11da1e39d17c87ab3f1641ceaf6e\",\"license\":\"MIT\"},\"contracts/reverseResolver/AbstractReverseResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ERC165} from \\\"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\\\";\\nimport {IExtendedResolver} from \\\"../resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {IAddressResolver} from \\\"../resolvers/profiles/IAddressResolver.sol\\\";\\nimport {IAddrResolver} from \\\"../resolvers/profiles/IAddrResolver.sol\\\";\\nimport {INameResolver} from \\\"../resolvers/profiles/INameResolver.sol\\\";\\nimport {INameReverser} from \\\"./INameReverser.sol\\\";\\nimport {ENSIP19, COIN_TYPE_DEFAULT, COIN_TYPE_ETH} from \\\"../utils/ENSIP19.sol\\\";\\n\\nabstract contract AbstractReverseResolver is\\n    IExtendedResolver,\\n    INameReverser,\\n    ERC165\\n{\\n    /// @notice The coin type for the resolver.\\n    uint256 public immutable coinType;\\n\\n    /// @notice The address returned by `addr(coinType)` for the resolver.\\n    address private immutable registrar;\\n\\n    /// @notice `resolve()` was called with a profile other than `name()` or `addr(*)`.\\n    /// @dev Error selector: `0x7b1c461b`\\n    error UnsupportedResolverProfile(bytes4 selector);\\n\\n    /// @notice `name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace.\\n    /// @dev Error selector: `0x5fe9a5df`\\n    error UnreachableName(bytes name);\\n\\n    constructor(uint256 _coinType, address _registrar) {\\n        coinType = _coinType;\\n        registrar = _registrar;\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view override returns (bool) {\\n        return\\n            interfaceId == type(IExtendedResolver).interfaceId ||\\n            interfaceId == type(INameReverser).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @notice The EVM Chain ID corresponding to the `coinType`.\\n    function chainId() external view returns (uint32) {\\n        return ENSIP19.chainFromCoinType(coinType);\\n    }\\n\\n    /// @dev Resolve one address to a name.\\n    ///      If this reverts `OffchainLookup`, it must return an abi-encoded result since\\n    ///      it is invoked during `resolve()`.\\n    function _resolveName(\\n        address addr\\n    ) internal view virtual returns (string memory name);\\n\\n    /// @notice Resolves the following profiles according to ENSIP-10:\\n    ///         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.\\n    ///         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.\\n    ///         Callers should enable EIP-3668.\\n    /// @dev This function may execute over multiple steps.\\n    /// @param name The reverse name to resolve, in normalised and DNS-encoded form.\\n    /// @param data The resolution data, as specified in ENSIP-10.\\n    /// @return result The encoded response for the requested profile.\\n    function resolve(\\n        bytes calldata name,\\n        bytes calldata data\\n    ) external view returns (bytes memory result) {\\n        bytes4 selector = bytes4(data);\\n        if (selector == INameResolver.name.selector) {\\n            (bytes memory a, uint256 ct) = ENSIP19.parse(name);\\n            if (\\n                a.length != 20 ||\\n                !(\\n                    coinType == COIN_TYPE_DEFAULT\\n                        ? ENSIP19.isEVMCoinType(ct)\\n                        : ct == coinType\\n                )\\n            ) {\\n                revert UnreachableName(name);\\n            }\\n            address addr = address(bytes20(a));\\n            return abi.encode(_resolveName(addr));\\n        } else if (selector == IAddrResolver.addr.selector) {\\n            (bool valid, ) = ENSIP19.parseNamespace(name, 0);\\n            if (!valid) revert UnreachableName(name);\\n            return\\n                abi.encode(coinType == COIN_TYPE_ETH ? registrar : address(0));\\n        } else if (selector == IAddressResolver.addr.selector) {\\n            (bool valid, ) = ENSIP19.parseNamespace(name, 0);\\n            if (!valid) revert UnreachableName(name);\\n            (, uint256 ct) = abi.decode(data[4:], (bytes32, uint256));\\n            return\\n                abi.encode(\\n                    coinType == ct ? abi.encodePacked(registrar) : new bytes(0)\\n                );\\n        } else {\\n            revert UnsupportedResolverProfile(selector);\\n        }\\n    }\\n\\n    // `INameReverser.resolveNames()` is not implemented here because it causes\\n    // an incorrect \\\"Unreachable code\\\" compiler warning if `_resolveName()` reverts.\\n    // https://github.com/ethereum/solidity/issues/15426#issuecomment-2917868211\\n    //\\n    // /// @inheritdoc INameReverser\\n    // function resolveNames(\\n    //     address[] memory addrs,\\n    //     uint8 /*perPage*/\\n    // ) external view returns (string[] memory names) {\\n    //     names = new string[](addrs.length);\\n    //     for (uint256 i; i < addrs.length; i++) {\\n    //         names[i] = _resolveName(addrs[i]);\\n    //     }\\n    // }\\n}\\n\",\"keccak256\":\"0x8ca67570f493d6baa3dc08dfad7313b91ca3dffb86f70f46f6c295f1f1ff449c\",\"license\":\"MIT\"},\"contracts/reverseResolver/DefaultReverseResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {AbstractReverseResolver} from \\\"./AbstractReverseResolver.sol\\\";\\nimport {IStandaloneReverseRegistrar} from \\\"../reverseRegistrar/IStandaloneReverseRegistrar.sol\\\";\\nimport {INameReverser} from \\\"./INameReverser.sol\\\";\\nimport {COIN_TYPE_DEFAULT} from \\\"../utils/ENSIP19.sol\\\";\\n\\n/// @title Default Reverse Resolver\\n/// @notice Reverses an EVM address using the `IStandaloneReverseRegistrar` for \\\"default.reverse\\\".\\ncontract DefaultReverseResolver is AbstractReverseResolver {\\n    /// @notice The reverse registrar contract for \\\"default.reverse\\\".\\n    IStandaloneReverseRegistrar public immutable defaultRegistrar;\\n\\n    constructor(\\n        IStandaloneReverseRegistrar _defaultRegistrar\\n    ) AbstractReverseResolver(COIN_TYPE_DEFAULT, address(_defaultRegistrar)) {\\n        defaultRegistrar = _defaultRegistrar;\\n    }\\n\\n    /// @inheritdoc AbstractReverseResolver\\n    function _resolveName(\\n        address addr\\n    ) internal view override returns (string memory name) {\\n        name = defaultRegistrar.nameForAddr(addr);\\n    }\\n\\n    /// @inheritdoc INameReverser\\n    function resolveNames(\\n        address[] memory addrs,\\n        uint8 /*perPage*/\\n    ) external view returns (string[] memory names) {\\n        names = new string[](addrs.length);\\n        for (uint256 i; i < addrs.length; i++) {\\n            names[i] = _resolveName(addrs[i]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7fa52508fd36dc5bd3ac7fd2e0e5324252e7631e7f094c3a9f65c99a91270d54\",\"license\":\"MIT\"},\"contracts/reverseResolver/INameReverser.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface INameReverser {\\n    /// @notice Resolve multiple EVM addresses to names.\\n    ///         Callers should enable EIP-3668.\\n    /// @dev This function may execute over multiple steps.\\n    /// @param addrs The addresses to resolve.\\n    /// @param perPage The maximum number of addresses to resolve per call.\\n    ///                Ignored if this function does not revert `OffchainLookup`.\\n    /// @return names The resolved names.\\n    function resolveNames(\\n        address[] memory addrs,\\n        uint8 perPage\\n    ) external view returns (string[] memory names);\\n}\\n\",\"keccak256\":\"0x7ffc12fd3d92799de64a63e936509e43bfb791e05900915a3a51235a2fe754d5\",\"license\":\"MIT\"},\"contracts/utils/ENSIP19.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {HexUtils} from \\\"../utils/HexUtils.sol\\\";\\nimport {NameCoder} from \\\"../utils/NameCoder.sol\\\";\\n\\nuint32 constant CHAIN_ID_ETH = 1;\\n\\nuint256 constant COIN_TYPE_ETH = 60;\\nuint256 constant COIN_TYPE_DEFAULT = 1 << 31; // 0x8000_0000\\n\\nstring constant SLUG_ETH = \\\"addr\\\"; // <=> COIN_TYPE_ETH\\nstring constant SLUG_DEFAULT = \\\"default\\\"; // <=> COIN_TYPE_DEFAULT\\nstring constant TLD_REVERSE = \\\"reverse\\\";\\n\\n/// @dev Library for generating reverse names according to ENSIP-19.\\n/// https://docs.ens.domains/ensip/19\\nlibrary ENSIP19 {\\n    /// @dev The supplied address was `0x`.\\n    error EmptyAddress();\\n\\n    /// @dev Extract Chain ID from `coinType`.\\n    /// @param coinType The coin type.\\n    /// @return The Chain ID or 0 if non-EVM Chain.\\n    function chainFromCoinType(\\n        uint256 coinType\\n    ) internal pure returns (uint32) {\\n        if (coinType == COIN_TYPE_ETH) return CHAIN_ID_ETH;\\n        coinType ^= COIN_TYPE_DEFAULT;\\n        return uint32(coinType < COIN_TYPE_DEFAULT ? coinType : 0);\\n    }\\n\\n    /// @dev Determine if Coin Type is for an EVM address.\\n    /// @param coinType The coin type.\\n    /// @return True if coin type represents an EVM address.\\n    function isEVMCoinType(uint256 coinType) internal pure returns (bool) {\\n        return coinType == COIN_TYPE_DEFAULT || chainFromCoinType(coinType) > 0;\\n    }\\n\\n    /// @dev Generate Reverse Name from Address + Coin Type.\\n    ///      Reverts `EmptyAddress` if `addressBytes` is `0x`.\\n    /// @param addressBytes The input address.\\n    /// @param coinType The coin type.\\n    /// @return The ENS reverse name, eg. `1234abcd.addr.reverse`.\\n    function reverseName(\\n        bytes memory addressBytes,\\n        uint256 coinType\\n    ) internal pure returns (string memory) {\\n        if (addressBytes.length == 0) {\\n            revert EmptyAddress();\\n        }\\n        return\\n            string(\\n                abi.encodePacked(\\n                    HexUtils.bytesToHex(addressBytes),\\n                    bytes1(\\\".\\\"),\\n                    coinType == COIN_TYPE_ETH\\n                        ? SLUG_ETH\\n                        : coinType == COIN_TYPE_DEFAULT\\n                            ? SLUG_DEFAULT\\n                            : HexUtils.unpaddedUintToHex(coinType, true),\\n                    bytes1(\\\".\\\"),\\n                    TLD_REVERSE\\n                )\\n            );\\n    }\\n\\n    /// @dev Parse Reverse Name into Address + Coin Type.\\n    ///      Matches: /^[0-9a-fA-F]+\\\\.([0-9a-f]{1,64}|addr|default)\\\\.reverse$/.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @return addressBytes The address or empty if invalid.\\n    /// @return coinType The coin type.\\n    function parse(\\n        bytes memory name\\n    ) internal pure returns (bytes memory addressBytes, uint256 coinType) {\\n        (, uint256 offset) = NameCoder.readLabel(name, 0);\\n        bool valid;\\n        (addressBytes, valid) = HexUtils.hexToBytes(name, 1, offset);\\n        if (!valid || addressBytes.length == 0) return (\\\"\\\", 0); // addressBytes not 1+ hex\\n        (valid, coinType) = parseNamespace(name, offset);\\n        if (!valid) return (\\\"\\\", 0); // invalid namespace\\n    }\\n\\n    /// @dev Parse Reverse Namespace into Coin Type.\\n    ///      Matches: /^([0-9a-f]{1,64}|addr|default)\\\\.reverse$/.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @param offset The offset to begin parsing.\\n    /// @return valid True if a valid reverse namespace.\\n    /// @return coinType The coin type.\\n    function parseNamespace(\\n        bytes memory name,\\n        uint256 offset\\n    ) internal pure returns (bool valid, uint256 coinType) {\\n        (bytes32 labelHash, uint256 offsetTLD) = NameCoder.readLabel(\\n            name,\\n            offset\\n        );\\n        if (labelHash == keccak256(bytes(SLUG_ETH))) {\\n            coinType = COIN_TYPE_ETH;\\n        } else if (labelHash == keccak256(bytes(SLUG_DEFAULT))) {\\n            coinType = COIN_TYPE_DEFAULT;\\n        } else if (labelHash == bytes32(0)) {\\n            return (false, 0); // no slug\\n        } else {\\n            (bytes32 word, bool validHex) = HexUtils.hexStringToBytes32(\\n                name,\\n                1 + offset,\\n                offsetTLD\\n            );\\n            if (!validHex) return (false, 0); // invalid coinType or too long\\n            coinType = uint256(word);\\n        }\\n        (labelHash, offset) = NameCoder.readLabel(name, offsetTLD);\\n        if (labelHash != keccak256(bytes(TLD_REVERSE))) return (false, 0); // invalid tld\\n        (labelHash, ) = NameCoder.readLabel(name, offset);\\n        if (labelHash != bytes32(0)) return (false, 0); // not tld\\n        valid = true;\\n    }\\n}\\n\",\"keccak256\":\"0x417e62b642c6a6c2efbb4601649b2fa1a9c46dc44c00869f687c074bfbe45945\",\"license\":\"MIT\"},\"contracts/utils/HexUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nlibrary HexUtils {\\n    /// @dev Convert `hexString[pos:end]` to `bytes32`.\\n    ///      Accepts 0-64 hex-chars.\\n    ///      Uses right alignment: `1` &rarr; `0000000000000000000000000000000000000000000000000000000000000001`.\\n    /// @param hexString The string to parse.\\n    /// @param pos The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return word The parsed bytes32.\\n    /// @return valid True if the parse was successful.\\n    function hexStringToBytes32(\\n        bytes memory hexString,\\n        uint256 pos,\\n        uint256 end\\n    ) internal pure returns (bytes32 word, bool valid) {\\n        uint256 nibbles = end - pos;\\n        if (nibbles > 64 || end > hexString.length) {\\n            return (bytes32(0), false); // too large or out of bounds\\n        }\\n        uint256 src;\\n        assembly {\\n            src := add(add(hexString, 32), pos)\\n        }\\n        valid = unsafeBytes(src, 0, nibbles);\\n        assembly {\\n            let pad := sub(32, shr(1, add(nibbles, 1))) // number of bytes\\n            word := shr(shl(3, pad), mload(0)) // right align\\n        }\\n    }\\n\\n    /// @dev Convert `hexString[pos:end]` to `address`.\\n    ///      Accepts exactly 40 hex-chars.\\n    /// @param hexString The string to parse.\\n    /// @param pos The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return addr The parsed address.\\n    /// @return valid True if the parse was successful.\\n    function hexToAddress(\\n        bytes memory hexString,\\n        uint256 pos,\\n        uint256 end\\n    ) internal pure returns (address addr, bool valid) {\\n        if (end - pos != 40) return (address(0), false); // wrong length\\n        bytes32 word;\\n        (word, valid) = hexStringToBytes32(hexString, pos, end);\\n        addr = address(uint160(uint256(word)));\\n    }\\n\\n    /// @dev Convert `hexString[pos:end]` to `bytes`.\\n    ///      Accepts 0+ hex-chars.\\n    /// @param pos The index to start parsing.\\n    /// @param end The (exclusive) index to stop parsing.\\n    /// @return v The parsed bytes.\\n    /// @return valid True if the parse was successful.\\n    function hexToBytes(\\n        bytes memory hexString,\\n        uint256 pos,\\n        uint256 end\\n    ) internal pure returns (bytes memory v, bool valid) {\\n        uint256 nibbles = end - pos;\\n        v = new bytes((1 + nibbles) >> 1); // round up\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(add(hexString, 32), pos)\\n            dst := add(v, 32)\\n        }\\n        valid = unsafeBytes(src, dst, nibbles);\\n    }\\n\\n    /// @dev Convert arbitrary hex-encoded memory to bytes.\\n    ///      If nibbles is odd, leading hex-char is padded, eg. `F` &rarr; `0x0F`.\\n    ///      Matches: /^[0-9a-f]*$/i.\\n    /// @param src The memory offset of first hex-char of input.\\n    /// @param dst The memory offset of first byte of output (cannot alias `src`).\\n    /// @param nibbles The number of hex-chars to convert.\\n    /// @return valid True if all characters were hex.\\n    function unsafeBytes(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure returns (bool valid) {\\n        assembly {\\n            function getHex(c, i) -> ascii {\\n                c := byte(i, c)\\n                // chars 48-57: 0-9\\n                if and(gt(c, 47), lt(c, 58)) {\\n                    ascii := sub(c, 48)\\n                    leave\\n                }\\n                // chars 65-70: A-F\\n                if and(gt(c, 64), lt(c, 71)) {\\n                    ascii := add(sub(c, 65), 10)\\n                    leave\\n                }\\n                // chars 97-102: a-f\\n                if and(gt(c, 96), lt(c, 103)) {\\n                    ascii := add(sub(c, 97), 10)\\n                    leave\\n                }\\n                // invalid char\\n                ascii := 0x100\\n            }\\n            valid := true\\n            let end := add(src, nibbles)\\n            if and(nibbles, 1) {\\n                let b := getHex(mload(src), 0) // \\\"f\\\" -> 15\\n                mstore8(dst, b) // write ascii byte\\n                src := add(src, 1) // update pointers\\n                dst := add(dst, 1)\\n                if gt(b, 255) {\\n                    valid := false\\n                    src := end // terminate loop\\n                }\\n            }\\n            for {} lt(src, end) {\\n                src := add(src, 2) // 2 nibbles\\n                dst := add(dst, 1) // per byte\\n            } {\\n                let word := mload(src) // read word (left aligned)\\n                let b := or(shl(4, getHex(word, 0)), getHex(word, 1)) // \\\"ff\\\" -> 255\\n                if gt(b, 255) {\\n                    valid := false\\n                    break\\n                }\\n                mstore8(dst, b) // write ascii byte\\n            }\\n        }\\n    }\\n\\n    /// @dev Format `address` as a hex string.\\n    /// @param addr The address to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function addressToHex(\\n        address addr\\n    ) internal pure returns (string memory hexString) {\\n        // return bytesToHex(abi.encodePacked(addr));\\n        hexString = new string(40);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, addr)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(12, dst, 40);\\n    }\\n\\n    /// @dev Format `uint256` as a variable-length hex string without zero padding.\\n    /// * unpaddedUintToHex(0, true)  = \\\"0\\\"\\n    /// * unpaddedUintToHex(1, true)  = \\\"1\\\"\\n    /// * unpaddedUintToHex(0, false) = \\\"00\\\"\\n    /// * unpaddedUintToHex(1, false) = \\\"01\\\"\\n    /// @param value The number to format.\\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\\n    /// @return hexString The corresponding hex string w/o an 0x-prefix.\\n    function unpaddedUintToHex(\\n        uint256 value,\\n        bool dropZeroNibble\\n    ) internal pure returns (string memory hexString) {\\n        uint256 temp = value;\\n        uint256 shift;\\n        for (uint256 b = 128; b >= 8; b >>= 1) {\\n            if (temp < (1 << b)) {\\n                shift += b; // number of zero upper bits\\n            } else {\\n                temp >>= b; // shift away lower half\\n            }\\n        }\\n        if (dropZeroNibble && temp < 16) shift += 4;\\n        uint256 nibbles = 64 - (shift >> 2);\\n        hexString = new string(nibbles);\\n        uint256 dst;\\n        assembly {\\n            mstore(0, shl(shift, value)) // left-align\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(0, dst, nibbles);\\n    }\\n\\n    /// @dev Format `bytes` as a hex string.\\n    /// @param v The bytes to format.\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\n    function bytesToHex(\\n        bytes memory v\\n    ) internal pure returns (string memory hexString) {\\n        uint256 nibbles = v.length << 1;\\n        hexString = new string(nibbles);\\n        uint256 src;\\n        uint256 dst;\\n        assembly {\\n            src := add(v, 32)\\n            dst := add(hexString, 32)\\n        }\\n        unsafeHex(src, dst, nibbles);\\n    }\\n\\n    /// @dev Converts arbitrary memory to a hex string.\\n    /// @param src The memory offset of first nibble of input.\\n    /// @param dst The memory offset of first hex-char of output (can alias `src`).\\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\\n    function unsafeHex(\\n        uint256 src,\\n        uint256 dst,\\n        uint256 nibbles\\n    ) internal pure {\\n        unchecked {\\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\\n                uint256 word;\\n                assembly {\\n                    word := mload(src)\\n                }\\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\\\"a\\\" - 10) => 0x57\\n                    assembly {\\n                        mstore8(dst, b)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x48e51ac631fabaa3e659cdc9f3c5743fa76e999213d65e931c486f9375dd2d4f\",\"license\":\"MIT\"},\"contracts/utils/NameCoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {HexUtils} from \\\"../utils/HexUtils.sol\\\";\\n\\n/// @dev Library for encoding/decoding names.\\n///\\n/// An ENS name is stop-separated labels, eg. \\\"aaa.bb.c\\\".\\n///\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\n/// eg. \\\"\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00\\\".\\n/// - maximum label length is 255 bytes.\\n/// - length = 0 is reserved for the terminator (root).\\n///\\n/// To encode a label larger than 255 bytes, use a hashed label.\\n/// A label of any length can be converted to a hashed label.\\n///\\n/// A hashed label is encoded as \\\"[\\\" + toHex(keccak256(label)) + \\\"]\\\".\\n/// eg. [af2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc] = \\\"vitalik\\\".\\n/// - always 66 bytes.\\n/// - matches: `/^\\\\[[0-9a-f]{64}\\\\]$/`.\\n///\\n/// w/o hashed labels: `dns.length == 2 + ens.length` and the mapping is injective.\\n///  w/ hashed labels: `dns.length == 2 + ens.split('.').map(x => x.utf8Length).sum(n => n > 255 ? 66 : n)`.\\nlibrary NameCoder {\\n    /// @dev The DNS-encoded name is malformed.\\n    error DNSDecodingFailed(bytes dns);\\n\\n    /// @dev A label of the ENS name has an invalid size.\\n    error DNSEncodingFailed(string ens);\\n\\n    /// @dev Same as `BytesUtils.readLabel()` but supports hashed labels.\\n    ///      Only the last labelHash is zero.\\n    ///      Disallows hashed label of zero (eg. `[0..0]`) to prevent confusion with terminator.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @param idx The offset into `name` to start reading.\\n    /// @return labelHash The resulting labelhash.\\n    /// @return newIdx The offset into `name` of the next label.\\n    function readLabel(\\n        bytes memory name,\\n        uint256 idx\\n    ) internal pure returns (bytes32 labelHash, uint256 newIdx) {\\n        if (idx >= name.length) revert DNSDecodingFailed(name); // \\\"readLabel: expected length\\\"\\n        uint256 len = uint256(uint8(name[idx++]));\\n        newIdx = idx + len;\\n        if (newIdx > name.length) revert DNSDecodingFailed(name); // \\\"readLabel: expected label\\\"\\n        if (len == 66 && name[idx] == \\\"[\\\" && name[newIdx - 1] == \\\"]\\\") {\\n            bool valid;\\n            (labelHash, valid) = HexUtils.hexStringToBytes32(\\n                name,\\n                idx + 1,\\n                newIdx - 1\\n            ); // will not revert\\n            if (!valid || labelHash == bytes32(0)) {\\n                revert DNSDecodingFailed(name); // \\\"readLabel: malformed\\\" or null literal\\n            }\\n        } else if (len > 0) {\\n            assembly {\\n                labelHash := keccak256(add(add(name, idx), 32), len)\\n            }\\n        }\\n    }\\n\\n    /// @dev Same as `BytesUtils.namehash()` but supports hashed labels.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param name The DNS-encoded name.\\n    /// @param idx The offset into name start hashing.\\n    /// @return hash The resulting namehash.\\n    function namehash(\\n        bytes memory name,\\n        uint256 idx\\n    ) internal pure returns (bytes32 hash) {\\n        (hash, idx) = readLabel(name, idx);\\n        if (hash == bytes32(0)) {\\n            if (idx != name.length) revert DNSDecodingFailed(name); // \\\"namehash: Junk at end of name\\\"\\n        } else {\\n            bytes32 parent = namehash(name, idx);\\n            assembly {\\n                mstore(0, parent)\\n                mstore(32, hash)\\n                hash := keccak256(0, 64)\\n            }\\n        }\\n    }\\n\\n    /// @dev Convert DNS-encoded name to ENS name.\\n    ///      Reverts `DNSDecodingFailed`.\\n    /// @param dns The DNS-encoded name to convert, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    /// @return ens The equivalent ENS name, eg. `aaa.bb.c`.\\n    function decode(\\n        bytes memory dns\\n    ) internal pure returns (string memory ens) {\\n        unchecked {\\n            uint256 n = dns.length;\\n            if (n == 1 && dns[0] == 0) return \\\"\\\"; // only valid answer is root\\n            if (n < 3) revert DNSDecodingFailed(dns);\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\n            uint256 src;\\n            uint256 dst;\\n            while (src < n) {\\n                uint8 len = uint8(dns[src++]);\\n                if (len == 0) break;\\n                uint256 end = src + len;\\n                if (end > dns.length) revert DNSDecodingFailed(dns); // overflow\\n                if (dst > 0) v[dst++] = \\\".\\\"; // skip first stop\\n                while (src < end) {\\n                    bytes1 x = dns[src++]; // read byte\\n                    if (x == \\\".\\\") revert DNSDecodingFailed(dns); // malicious label\\n                    v[dst++] = x; // write byte\\n                }\\n            }\\n            if (src != dns.length) revert DNSDecodingFailed(dns); // junk at end\\n            return string(v);\\n        }\\n    }\\n\\n    /// @dev Convert ENS name to DNS-encoded name.\\n    ///      Hashes labels longer than 255 bytes.\\n    ///      Reverts `DNSEncodingFailed`.\\n    /// @param ens The ENS name to convert, eg. `aaa.bb.c`.\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\x03aaa\\\\x02bb\\\\x01c\\\\x00`.\\n    function encode(\\n        string memory ens\\n    ) internal pure returns (bytes memory dns) {\\n        unchecked {\\n            uint256 n = bytes(ens).length;\\n            if (n == 0) return hex\\\"00\\\"; // root\\n            dns = new bytes(n + 2);\\n            uint256 start;\\n            assembly {\\n                start := add(dns, 32) // first byte of output\\n            }\\n            uint256 end = start; // remember position to write length\\n            for (uint256 i; i < n; i++) {\\n                bytes1 x = bytes(ens)[i]; // read byte\\n                if (x == \\\".\\\") {\\n                    start = _createHashedLabel(start, end);\\n                    if (start == 0) revert DNSEncodingFailed(ens);\\n                    end = start; // jump to next position\\n                } else {\\n                    assembly {\\n                        end := add(end, 1) // increase length\\n                        mstore(end, x) // write byte\\n                    }\\n                }\\n            }\\n            start = _createHashedLabel(start, end);\\n            if (start == 0) revert DNSEncodingFailed(ens);\\n            assembly {\\n                mstore8(start, 0) // terminal byte\\n                mstore(dns, sub(start, add(dns, 31))) // truncate length\\n            }\\n        }\\n    }\\n\\n    /// @dev Write the label length.\\n    ///      If longer than 255, writes a hashed label instead.\\n    /// @param start The memory offset of the length-prefixed label.\\n    /// @param end The memory offset at the end of the label.\\n    /// @return next The memory offset for the next label.\\n    ///              Returns 0 if label is empty (handled by caller).\\n    function _createHashedLabel(\\n        uint256 start,\\n        uint256 end\\n    ) internal pure returns (uint256 next) {\\n        uint256 size = end - start; // length of label\\n        if (size > 255) {\\n            assembly {\\n                mstore(0, keccak256(add(start, 1), size)) // compute hash of label\\n            }\\n            HexUtils.unsafeHex(0, start + 2, 64); // override label with hex(hash)\\n            assembly {\\n                mstore8(add(start, 1), 0x5B) // \\\"[\\\"\\n                mstore8(add(start, 66), 0x5D) // \\\"]\\\"\\n            }\\n            size = 66;\\n        }\\n        if (size > 0) {\\n            assembly {\\n                mstore8(start, size) // update length\\n            }\\n            next = start + 1 + size; // advance\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8fd7af9cec38612e8041c13d4c3eb9c11fccdcbed4fac40020a4b84672f0aa85\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60e060405234801561001057600080fd5b5060405161176438038061176483398101604081905261002f9161004d565b63800000006080526001600160a01b031660a081905260c05261007d565b60006020828403121561005f57600080fd5b81516001600160a01b038116811461007657600080fd5b9392505050565b60805160a05160c0516116886100dc600039600081816101360152610873015260008181610597015261073901526000818160a4015281816103c0015281816103e60152818161056a015281816106db015261080201526116886000f3fe608060405234801561001057600080fd5b50600436106100725760003560e01c80639061b923116100505780639061b923146100f45780639a8a059214610114578063b16eab651461013157600080fd5b806301ffc9a7146100775780631fe93ea81461009f5780632edbbd16146100d4575b600080fd5b61008a610085366004610fff565b61017d565b60405190151581526020015b60405180910390f35b6100c67f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610096565b6100e76100e23660046110dc565b610262565b604051610096919061122f565b6101076101023660046112f4565b61030e565b6040516100969190611365565b61011c6107fb565b60405163ffffffff9091168152602001610096565b6101587f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610096565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f9061b92300000000000000000000000000000000000000000000000000000000148061021057507fffffffff0000000000000000000000000000000000000000000000000000000082167f2edbbd1600000000000000000000000000000000000000000000000000000000145b8061025c57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6060825167ffffffffffffffff81111561027e5761027e611048565b6040519080825280602002602001820160405280156102b157816020015b606081526020019060019003908161029c5790505b50905060005b8351811015610307576102e28482815181106102d5576102d5611378565b602002602001015161082b565b8282815181106102f4576102f4611378565b60209081029190910101526001016102b7565b5092915050565b6060600061031c83856113a7565b90507f96e0cbcf000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000082160161049e576000806103a988888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061090292505050565b9150915081516014141580610417575063800000007f00000000000000000000000000000000000000000000000000000000000000001461040c577f00000000000000000000000000000000000000000000000000000000000000008114610415565b6104158161098f565b155b1561045b5787876040517f5fe9a5df00000000000000000000000000000000000000000000000000000000815260040161045292919061140c565b60405180910390fd5b600061046683611459565b60601c90506104748161082b565b6040516020016104849190611365565b6040516020818303038152906040529450505050506107f3565b7fc4c4a822000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008216016105f157600061052887878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525092506109b6915050565b509050806105665786866040517f5fe9a5df00000000000000000000000000000000000000000000000000000000815260040161045292919061140c565b603c7f0000000000000000000000000000000000000000000000000000000000000000146105955760006105b7565b7f00000000000000000000000000000000000000000000000000000000000000005b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015201604051602081830303815290604052925050506107f3565b7f0e3481fa000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000082160161079d57600061067b87878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525092506109b6915050565b509050806106b95786866040517f5fe9a5df00000000000000000000000000000000000000000000000000000000815260040161045292919061140c565b60006106c885600481896114c5565b8101906106d591906114ef565b915050807f00000000000000000000000000000000000000000000000000000000000000001461071357604080516000815260208101909152610774565b6040517fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660208201526034016040516020818303038152906040525b6040516020016107849190611365565b60405160208183030381529060405293505050506107f3565b6040517f7b1c461b0000000000000000000000000000000000000000000000000000000081527fffffffff0000000000000000000000000000000000000000000000000000000082166004820152602401610452565b949350505050565b60006108267f0000000000000000000000000000000000000000000000000000000000000000610b87565b905090565b6040517f4ec3bd2300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526060917f000000000000000000000000000000000000000000000000000000000000000090911690634ec3bd2390602401600060405180830381865afa1580156108bc573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261025c9190810190611511565b6060600080610912846000610bb3565b915050600061092385600184610dc8565b909450905080158061093457508351155b156109575760006040518060200160405280600081525090935093505050915091565b61096185836109b6565b93509050806109885760006040518060200160405280600081525090935093505050915091565b5050915091565b6000638000000082148061025c575060006109a983610b87565b63ffffffff161192915050565b6000806000806109c68686610bb3565b60408051808201909152600481527f616464720000000000000000000000000000000000000000000000000000000060209091015290925090507f1a1ebb7848707a05591e7f7176db930a822cb7ceab700d19f68c7f26724dafb68201610a3057603c9250610ae0565b60408051808201909152600781527f64656661756c74000000000000000000000000000000000000000000000000006020909101527f301183f75670b4a9a2edb381b1d7533ad1e4387f1c77824f5fd582d2a43998d88201610a985763800000009250610ae0565b81610aab57600080935093505050610b80565b600080610ac388610abd8960016115f4565b85610e4e565b9150915080610adc576000809550955050505050610b80565b5092505b610aea8682610bb3565b60408051808201909152600781527f7265766572736500000000000000000000000000000000000000000000000000602090910152955091507fdec08c9dbbdd0890e300eb5062089b2d4b1c40e3673bbccb5423f7b37dcf9a9c8214610b5857600080935093505050610b80565b610b628686610bb3565b5091508115610b7957600080935093505050610b80565b6001935050505b9250929050565b6000603c8203610b9957506001919050565b6380000000918218918210610baf57600061025c565b5090565b60008083518310610bf257836040517fba4adc230000000000000000000000000000000000000000000000000000000081526004016104529190611365565b60008484610bff81611607565b955081518110610c1157610c11611378565b016020015160f81c9050610c2581856115f4565b91508451821115610c6457846040517fba4adc230000000000000000000000000000000000000000000000000000000081526004016104529190611365565b806042148015610ccc5750848481518110610c8157610c81611378565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f5b00000000000000000000000000000000000000000000000000000000000000145b8015610d3a575084610cdf60018461163f565b81518110610cef57610cef611378565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f5d00000000000000000000000000000000000000000000000000000000000000145b15610daf576000610d6086610d508760016115f4565b610d5b60018761163f565b610e4e565b9094509050801580610d70575083155b15610da957856040517fba4adc230000000000000000000000000000000000000000000000000000000081526004016104529190611365565b50610dc0565b8015610dc057806020858701012092505b509250929050565b6060600080610dd7858561163f565b90506001610de582826115f4565b901c67ffffffffffffffff811115610dff57610dff611048565b6040519080825280601f01601f191660200182016040528015610e29576020820181803683370190505b50925060208587018101908401610e41828285610eb3565b9350505050935093915050565b60008080610e5c858561163f565b90506040811180610e6d5750855184115b15610e7f575060009150819050610eab565b858501602001610e9181600084610eb3565b92506001820160011c6020036000518160031b1c94505050505b935093915050565b6000610f6d565b811a6000602f8211603a83101615610ef557507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd0810161025c565b60478210604083111615610f2c57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc9810161025c565b60678210606083111615610f6357507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa9810161025c565b5061010092915050565b50600183820182821615610fa957610f8760008651610eba565b80855360018601955060018501945060ff811115610fa757600092508195505b505b80851015610ff7578451610fbe600182610eba565b610fc9600083610eba565b60041b17905060ff811115610fe2576000925050610ff7565b80855350600285019450600184019350610fa9565b509392505050565b60006020828403121561101157600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461104157600080fd5b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156110be576110be611048565b604052919050565b803560ff811681146110d757600080fd5b919050565b600080604083850312156110ef57600080fd5b823567ffffffffffffffff81111561110657600080fd5b8301601f8101851361111757600080fd5b803567ffffffffffffffff81111561113157611131611048565b8060051b61114160208201611077565b9182526020818401810192908101908884111561115d57600080fd5b6020850194505b838510156111a4578435925073ffffffffffffffffffffffffffffffffffffffff8316831461119257600080fd5b82825260209485019490910190611164565b80965050505050506111b8602084016110c6565b90509250929050565b60005b838110156111dc5781810151838201526020016111c4565b50506000910152565b600081518084526111fd8160208601602086016111c1565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000602082016020835280845180835260408501915060408160051b86010192506020860160005b828110156112a6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08786030184526112918583516111e5565b94506020938401939190910190600101611257565b50929695505050505050565b60008083601f8401126112c457600080fd5b50813567ffffffffffffffff8111156112dc57600080fd5b602083019150836020828501011115610b8057600080fd5b6000806000806040858703121561130a57600080fd5b843567ffffffffffffffff81111561132157600080fd5b61132d878288016112b2565b909550935050602085013567ffffffffffffffff81111561134d57600080fd5b611359878288016112b2565b95989497509550505050565b60208152600061104160208301846111e5565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b80357fffffffff000000000000000000000000000000000000000000000000000000008116906004841015610307577fffffffff00000000000000000000000000000000000000000000000000000000808560040360031b1b82161691505092915050565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b805160208201517fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008116919060148210156114be577fffffffffffffffffffffffffffffffffffffffff000000000000000000000000808360140360031b1b82161692505b5050919050565b600080858511156114d557600080fd5b838611156114e257600080fd5b5050820193919092039150565b6000806040838503121561150257600080fd5b50508035926020909101359150565b60006020828403121561152357600080fd5b815167ffffffffffffffff81111561153a57600080fd5b8201601f8101841361154b57600080fd5b805167ffffffffffffffff81111561156557611565611048565b61159660207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611077565b8181528560208385010111156115ab57600080fd5b6115bc8260208301602086016111c1565b95945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561025c5761025c6115c5565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611638576116386115c5565b5060010190565b8181038181111561025c5761025c6115c556fea2646970667358221220969643a54d4e9587668302ccd8e867485146842cbfb928b541f0c6f636b82ae964736f6c634300081a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100725760003560e01c80639061b923116100505780639061b923146100f45780639a8a059214610114578063b16eab651461013157600080fd5b806301ffc9a7146100775780631fe93ea81461009f5780632edbbd16146100d4575b600080fd5b61008a610085366004610fff565b61017d565b60405190151581526020015b60405180910390f35b6100c67f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610096565b6100e76100e23660046110dc565b610262565b604051610096919061122f565b6101076101023660046112f4565b61030e565b6040516100969190611365565b61011c6107fb565b60405163ffffffff9091168152602001610096565b6101587f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610096565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f9061b92300000000000000000000000000000000000000000000000000000000148061021057507fffffffff0000000000000000000000000000000000000000000000000000000082167f2edbbd1600000000000000000000000000000000000000000000000000000000145b8061025c57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6060825167ffffffffffffffff81111561027e5761027e611048565b6040519080825280602002602001820160405280156102b157816020015b606081526020019060019003908161029c5790505b50905060005b8351811015610307576102e28482815181106102d5576102d5611378565b602002602001015161082b565b8282815181106102f4576102f4611378565b60209081029190910101526001016102b7565b5092915050565b6060600061031c83856113a7565b90507f96e0cbcf000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000082160161049e576000806103a988888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061090292505050565b9150915081516014141580610417575063800000007f00000000000000000000000000000000000000000000000000000000000000001461040c577f00000000000000000000000000000000000000000000000000000000000000008114610415565b6104158161098f565b155b1561045b5787876040517f5fe9a5df00000000000000000000000000000000000000000000000000000000815260040161045292919061140c565b60405180910390fd5b600061046683611459565b60601c90506104748161082b565b6040516020016104849190611365565b6040516020818303038152906040529450505050506107f3565b7fc4c4a822000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008216016105f157600061052887878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525092506109b6915050565b509050806105665786866040517f5fe9a5df00000000000000000000000000000000000000000000000000000000815260040161045292919061140c565b603c7f0000000000000000000000000000000000000000000000000000000000000000146105955760006105b7565b7f00000000000000000000000000000000000000000000000000000000000000005b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015201604051602081830303815290604052925050506107f3565b7f0e3481fa000000000000000000000000000000000000000000000000000000007fffffffff0000000000000000000000000000000000000000000000000000000082160161079d57600061067b87878080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525092506109b6915050565b509050806106b95786866040517f5fe9a5df00000000000000000000000000000000000000000000000000000000815260040161045292919061140c565b60006106c885600481896114c5565b8101906106d591906114ef565b915050807f00000000000000000000000000000000000000000000000000000000000000001461071357604080516000815260208101909152610774565b6040517fffffffffffffffffffffffffffffffffffffffff0000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000060601b1660208201526034016040516020818303038152906040525b6040516020016107849190611365565b60405160208183030381529060405293505050506107f3565b6040517f7b1c461b0000000000000000000000000000000000000000000000000000000081527fffffffff0000000000000000000000000000000000000000000000000000000082166004820152602401610452565b949350505050565b60006108267f0000000000000000000000000000000000000000000000000000000000000000610b87565b905090565b6040517f4ec3bd2300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526060917f000000000000000000000000000000000000000000000000000000000000000090911690634ec3bd2390602401600060405180830381865afa1580156108bc573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261025c9190810190611511565b6060600080610912846000610bb3565b915050600061092385600184610dc8565b909450905080158061093457508351155b156109575760006040518060200160405280600081525090935093505050915091565b61096185836109b6565b93509050806109885760006040518060200160405280600081525090935093505050915091565b5050915091565b6000638000000082148061025c575060006109a983610b87565b63ffffffff161192915050565b6000806000806109c68686610bb3565b60408051808201909152600481527f616464720000000000000000000000000000000000000000000000000000000060209091015290925090507f1a1ebb7848707a05591e7f7176db930a822cb7ceab700d19f68c7f26724dafb68201610a3057603c9250610ae0565b60408051808201909152600781527f64656661756c74000000000000000000000000000000000000000000000000006020909101527f301183f75670b4a9a2edb381b1d7533ad1e4387f1c77824f5fd582d2a43998d88201610a985763800000009250610ae0565b81610aab57600080935093505050610b80565b600080610ac388610abd8960016115f4565b85610e4e565b9150915080610adc576000809550955050505050610b80565b5092505b610aea8682610bb3565b60408051808201909152600781527f7265766572736500000000000000000000000000000000000000000000000000602090910152955091507fdec08c9dbbdd0890e300eb5062089b2d4b1c40e3673bbccb5423f7b37dcf9a9c8214610b5857600080935093505050610b80565b610b628686610bb3565b5091508115610b7957600080935093505050610b80565b6001935050505b9250929050565b6000603c8203610b9957506001919050565b6380000000918218918210610baf57600061025c565b5090565b60008083518310610bf257836040517fba4adc230000000000000000000000000000000000000000000000000000000081526004016104529190611365565b60008484610bff81611607565b955081518110610c1157610c11611378565b016020015160f81c9050610c2581856115f4565b91508451821115610c6457846040517fba4adc230000000000000000000000000000000000000000000000000000000081526004016104529190611365565b806042148015610ccc5750848481518110610c8157610c81611378565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f5b00000000000000000000000000000000000000000000000000000000000000145b8015610d3a575084610cdf60018461163f565b81518110610cef57610cef611378565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f5d00000000000000000000000000000000000000000000000000000000000000145b15610daf576000610d6086610d508760016115f4565b610d5b60018761163f565b610e4e565b9094509050801580610d70575083155b15610da957856040517fba4adc230000000000000000000000000000000000000000000000000000000081526004016104529190611365565b50610dc0565b8015610dc057806020858701012092505b509250929050565b6060600080610dd7858561163f565b90506001610de582826115f4565b901c67ffffffffffffffff811115610dff57610dff611048565b6040519080825280601f01601f191660200182016040528015610e29576020820181803683370190505b50925060208587018101908401610e41828285610eb3565b9350505050935093915050565b60008080610e5c858561163f565b90506040811180610e6d5750855184115b15610e7f575060009150819050610eab565b858501602001610e9181600084610eb3565b92506001820160011c6020036000518160031b1c94505050505b935093915050565b6000610f6d565b811a6000602f8211603a83101615610ef557507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd0810161025c565b60478210604083111615610f2c57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc9810161025c565b60678210606083111615610f6357507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa9810161025c565b5061010092915050565b50600183820182821615610fa957610f8760008651610eba565b80855360018601955060018501945060ff811115610fa757600092508195505b505b80851015610ff7578451610fbe600182610eba565b610fc9600083610eba565b60041b17905060ff811115610fe2576000925050610ff7565b80855350600285019450600184019350610fa9565b509392505050565b60006020828403121561101157600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461104157600080fd5b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156110be576110be611048565b604052919050565b803560ff811681146110d757600080fd5b919050565b600080604083850312156110ef57600080fd5b823567ffffffffffffffff81111561110657600080fd5b8301601f8101851361111757600080fd5b803567ffffffffffffffff81111561113157611131611048565b8060051b61114160208201611077565b9182526020818401810192908101908884111561115d57600080fd5b6020850194505b838510156111a4578435925073ffffffffffffffffffffffffffffffffffffffff8316831461119257600080fd5b82825260209485019490910190611164565b80965050505050506111b8602084016110c6565b90509250929050565b60005b838110156111dc5781810151838201526020016111c4565b50506000910152565b600081518084526111fd8160208601602086016111c1565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000602082016020835280845180835260408501915060408160051b86010192506020860160005b828110156112a6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08786030184526112918583516111e5565b94506020938401939190910190600101611257565b50929695505050505050565b60008083601f8401126112c457600080fd5b50813567ffffffffffffffff8111156112dc57600080fd5b602083019150836020828501011115610b8057600080fd5b6000806000806040858703121561130a57600080fd5b843567ffffffffffffffff81111561132157600080fd5b61132d878288016112b2565b909550935050602085013567ffffffffffffffff81111561134d57600080fd5b611359878288016112b2565b95989497509550505050565b60208152600061104160208301846111e5565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b80357fffffffff000000000000000000000000000000000000000000000000000000008116906004841015610307577fffffffff00000000000000000000000000000000000000000000000000000000808560040360031b1b82161691505092915050565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b805160208201517fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008116919060148210156114be577fffffffffffffffffffffffffffffffffffffffff000000000000000000000000808360140360031b1b82161692505b5050919050565b600080858511156114d557600080fd5b838611156114e257600080fd5b5050820193919092039150565b6000806040838503121561150257600080fd5b50508035926020909101359150565b60006020828403121561152357600080fd5b815167ffffffffffffffff81111561153a57600080fd5b8201601f8101841361154b57600080fd5b805167ffffffffffffffff81111561156557611565611048565b61159660207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601611077565b8181528560208385010111156115ab57600080fd5b6115bc8260208301602086016111c1565b95945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8082018082111561025c5761025c6115c5565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611638576116386115c5565b5060010190565b8181038181111561025c5761025c6115c556fea2646970667358221220969643a54d4e9587668302ccd8e867485146842cbfb928b541f0c6f636b82ae964736f6c634300081a0033",
  "devdoc": {
    "errors": {
      "DNSDecodingFailed(bytes)": [
        {
          "details": "The DNS-encoded name is malformed."
        }
      ],
      "UnreachableName(bytes)": [
        {
          "details": "Error selector: `0x5fe9a5df`"
        }
      ],
      "UnsupportedResolverProfile(bytes4)": [
        {
          "details": "Error selector: `0x7b1c461b`"
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "resolve(bytes,bytes)": {
        "details": "This function may execute over multiple steps.",
        "params": {
          "data": "The resolution data, as specified in ENSIP-10.",
          "name": "The reverse name to resolve, in normalised and DNS-encoded form."
        },
        "returns": {
          "result": "The encoded response for the requested profile."
        }
      },
      "resolveNames(address[],uint8)": {
        "details": "This function may execute over multiple steps.",
        "params": {
          "addrs": "The addresses to resolve.",
          "perPage": "The maximum number of addresses to resolve per call.                Ignored if this function does not revert `OffchainLookup`."
        },
        "returns": {
          "names": "The resolved names."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      }
    },
    "title": "Default Reverse Resolver",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "UnreachableName(bytes)": [
        {
          "notice": "`name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace."
        }
      ],
      "UnsupportedResolverProfile(bytes4)": [
        {
          "notice": "`resolve()` was called with a profile other than `name()` or `addr(*)`."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "chainId()": {
        "notice": "The EVM Chain ID corresponding to the `coinType`."
      },
      "coinType()": {
        "notice": "The coin type for the resolver."
      },
      "defaultRegistrar()": {
        "notice": "The reverse registrar contract for \"default.reverse\"."
      },
      "resolve(bytes,bytes)": {
        "notice": "Resolves the following profiles according to ENSIP-10:         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.         Callers should enable EIP-3668."
      },
      "resolveNames(address[],uint8)": {
        "notice": "Resolve multiple EVM addresses to names.         Callers should enable EIP-3668."
      }
    },
    "notice": "Reverses an EVM address using the `IStandaloneReverseRegistrar` for \"default.reverse\".",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}